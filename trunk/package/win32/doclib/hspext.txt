------------------------------------------------------------------------------
HSPEXT ver3.4  REFERENCE MANUAL                     HSP : Hot Soup Processor  
ＨＳＰ拡張DLLリファレンス             copyright 1999-2014 (c) onion software  
------------------------------------------------------------------------------

・はじめに

	このDLLは、Hot Soup Processor ver3以降とともに使用することで、様々な
	機能拡張を行なうことのできるプラグインモジュールです。
	この拡張DLLを使用することで、多くの新規命令が追加され、レジストリ操作、
	簡易数学関数、シリアル通信、拡張ダイアログ表示、拡張ファイルアクセスなど
	多くの機能がHSPからコントロールできるようになります。
	これらの命令は、HSP単体では実現できないようなツール、ユーティリティの
	作成に役立つものが多く、さらに高度なアプリケーション開発が可能になります。


・使用方法の概要

	拡張プラグインのファイル、HSPEXT.DLLは、HSED3.EXEおよび、HSP3.EXEのある
	ディレクトリと同じ場所に置いてください。
	(実行に使われているHSP3.EXEと同じディレクトリに、HSPEXT.DLLがない場合は
	エラーになります)
	また、スクリプトを作成する場合には、hspext.asをスクリプトと同じディレク
	トリに置き、スクリプトの先頭に必ず「#include "hspext.as"」という行を追加
	してください。以上で、HSPの機能が拡張され、このリファレンスで説明を
	している命令を使用することができるようになります。
	まず最初に、試しに付属のサンプルスクリプトを実行してみてください。
	拡張された機能の簡単な使用例を見ることができるはずです。


・更新履歴

	2009/3/09

		シリアルポートの10番目(COM10)以上を指定可能に修正(sharkpp)
		pipeput,pipegetでフリーズ、エラーが発生する不具合を修正(sharkpp)

	2007/7/15

		dirlist2命令の不具合を修正。

	2004/5/21

		grotate命令でコピー元Y座標の指定が正しく反映されない不具合を修正
		aplstr命令で全角文字がWindows2000以降で使用できない不具合を修正。

	2004/3/1

		画像の変形、回転拡大縮小を行なうgrotate,grect,gsquare命令を追加。

	2003/3/1

		通信ポートデバイスの状態取得のためのcomstat、およびコントロールのための
		comcontrol命令を追加。

	2002/5/13

		サブディレクトリを含めたフォルダ情報を取得するdirlist2関連命令を追加。
		sysinfo命令を削除。

	2001/9/9

		fxdir命令でアイテムIDの開放が行なわれていない不具合を修正。
		fxdir命令でテンポラリのディレクトリ取得が間違っていたのを修正。

	2000/11/5

		clipsetg命令がWindows2000で使用できない不具合を修正。

	2000/5/1

		computc/pipeexec/pipeget/pipeput命令を追加。
		fxinfo命令によるディスク空き容量取得をFAT32に対応させた。

	1999/12/2

		ver2.5に同梱。


・注意点

	HSPEXT.DLLは、HSP3.EXEと同時に使用されるプラグインファイルです。
	EXEファイルを作成した場合でも、HSPEXT.DLLをEXEファイルと同じディレクトリ
	に置かないと動作しません。また、packfileにDLLを追加することはできません。

	HSP本体は、Windows95、98、NT3.51以降、2000、XP等で動作確認を行なっていますが、
	HSPEXT.DLLを含む拡張プラグインが、すべてのバージョンで動作するかどうかは
	保証されていません。
	HSPEXT.DLLを使用したソフトを公開する場合は、動作を確認したもののみを明記
	下さい。


・著作権および連絡先

	ユーザーがHSPを使って作成したオリジナルのソフトウェア(実行ファイル)の
	権利は、それを作成したユーザーに属します。
	有償・無償を問わずHSPEXT.DLLを自由に配布することができ、onion softwareの
	著作権表示義務もありません。
	ユーザーが作成したオリジナルのソフトウェアに対してonion softwareが著作権を
	主張することはありません。

	HSPEXTプラグインは、onion softwareの著作物です。
	onion softwareは本プログラムによって生じた、いかなる損害についても
	保証いたしません。自己の責任の範囲で使用してください。
	HSPEXT.DLLは、Microsoft Visual Studio.NET 2003でコンパイルされて います。 


・命令一覧

	フルカラー画面操作命令

	gfini p1,p2						対象画面を設定
	gfcopy p1						半透明コピー
	gfdec p1,p2,p3					画面の色減算
	gfinc p1,p2,p3					画面の色加算
	hsvcolor p1,p2,p3				HSV形式色指定


	拡張画面操作命令

	grect p1,p2,p3,p4,p5				回転する矩形で塗りつぶす
	grotate p1,p2,p3,p4,p5,p6			矩形画像を回転してコピー
	gsquare p1,p2,p3,p4,p5				任意の四角形画像をコピー


	システム情報取得命令

	sysinfo p1,p2					システム情報を取得
	sysexit p1						システムに終了を通知


	簡易数学関数命令

	emath p1						固定小数の精度を指定
	emstr p1,p2,p3					固定小数を文字列に変換
	emcnv p1,"val"					文字列を固定小数に変換
	emint p1,p2						固定小数を整数に変換
	emsin p1,p2						サインを求める
	emcos p1,p2						コサインを求める
	emsqr p1,p2						平方根を求める
	ematan p1,p2,p3					アークタンジェントを求める


	レジストリ操作命令

	regkey p1,"key-name",p2			レジストリキー指定
	getreg p1,"section",p2,p3		レジストリ読み出し
	setreg p1,"section",p2,p3		レジストリ書き込み
	regkill p1,"key-name"			レジストリキー削除
	reglist p1,p2					レジストリ一覧取得


	シリアル通信命令

	comopen p1,"protocol"			シリアルポートを初期化
	comclose						シリアルポートを解放
	computc p1					シリアルポートに送信
	comput "send-string"			シリアルポートに送信
	comgetc p1						シリアルポートから受信
	comget p1,p2					シリアルポートから文字列を受信
	comstat p1						シリアルポートの状態取得
	comcontrol p1					シリアルポートの特殊コントロール


	拡張ファイルアクセス命令

	fxcopy p1,"dest",p2				ファイルのコピー・移動
	fxren  p1,"new name"			ファイル名を変更
	fxinfo p1,p2,p3					ドライブ情報を取得
	fxaget p1,"file"				ファイル属性を取得
	fxaset "file",p1				ファイル属性を設定
	fxtget p1,"file"				タイムスタンプを取得
	fxtset p1,"file"				タイムスタンプを設定
	selfolder p1,"message"			フォルダ選択ダイアログ
	fxshort p1,"file"				DOSファイルネームを取得
	fxdir p1,p2						特殊なディレクトリ名を取得
	fxlink p1,"path"				ショートカットを作成
	lzdist "path"					圧縮解凍先ディレクトリ指定
	lzcopy "name"					圧縮解凍コピー


	クリップボードアクセス命令

	clipset "strings"				クリップボードテキスト転送
	clipsetg					クリップボード画像転送
	clipget p1,p2					クリップボードテキスト取得


	アプリケーションキャプチャー命令

	aplsel "window name",p1				任意のウインドゥ捕獲
	aplobj "object name",p1				任意のオブジェクト捕獲
	aplact						ウインドゥをアクティブにする
	aplfocus					キー送信先をデフォルトにする
	aplstr "strings"				文字列をキー送信
	aplkey p1,p2					キーコード送信
	aplkeyu p1,p2					キー押し下げ送信
	aplkeyd p1,p2					キー押し上げ送信
	aplget p1,p2					オブジェクトの文字列を取得
	apledit p1,p2,p3				エディットコントロール情報取得
	pipeput p1					パイプに1byte送る
	pipeget p1					パイプ付き実行監視
	pipeexec p1,"filename",p2			パイプ付き実行


・フルカラー画面操作命令

	フルカラーモード時専用のグラフィック操作命令です。
	指定した範囲を黒に向かってフェード、白に向かってフェードや、
	半透明コピーをすることが可能です。


	gfini p1,p2					対象画面を設定

	p1=0〜(0)  : 画面操作を行なうXサイズ(dot単位)
	p2=0〜(0)  : 画面操作を行なうYサイズ(dot単位)

	・説明

		フルカラー画面操作命令を行なう対象の画面を設定します。
		必ずgfini命令で対象の画面を設定してから、他のフルカラー
		画面操作命令を使用してください。
		gfini命令では、現在gsel命令で選択されているウインドゥの
		カレントポジションから、p1,p2で指定したサイズを描画対象
		とします。
		必ずフルカラーモードで初期設定をした画面に対して行なって
		ください。

	gfcopy p1					半透明コピー

	p1=0〜100(0)  : 半透明コピーレート(%)

	・説明

		p1で指定したレートで画面イメージをコピーします。
		コピー先は、gfini命令で設定した画面になります。
		コピー元は、gfcopy命令が実行された時点に、描画先に設定
		されている画面のカレントポジションになります。
		p1のレートは0〜100(%)で、100%は普通のコピーになります。
		この命令を実行しただけでは実際の画面は更新されません。
		「redraw 1」などで画面の更新を行なって初めて反映されます。

	gfdec p1,p2,p3					画面の色減算

	p1,p2,p3=0〜255(0) : 色コード（R,G,Bの輝度)

	・説明

		gfini命令で設定した画面内のすべてのドットに対して、
		p1,p2,p3で指定した数値を減算します。
		p1はR、p2はG、p3はBに対して行なわれます。
		これはフルカラーモードにおいて、ゆっくりと色を落として
		いく(フェードアウト)の効果を出す時に有効です。
		この命令を実行しただけでは実際の画面は更新されません。
		「redraw 1」などで画面の更新を行なって初めて反映されます。

	gfinc p1,p2,p3					画面の色加算

	p1,p2,p3=0〜255(0) : 色コード（R,G,Bの輝度)

	・説明

		gfini命令で設定した画面内のすべてのドットに対して、
		p1,p2,p3で指定した数値を加算します。
		p1はR、p2はG、p3はBに対して行なわれます。
		これはフルカラーモードにおいて、ゆっくりと色を白にして
		いく(ホワイトアウト)の効果を出す時に有効です。
		この命令を実行しただけでは実際の画面は更新されません。
		「redraw 1」などで画面の更新を行なって初めて反映されます。

	hsvcolor p1,p2,p3				HSV形式色指定

	p1=0〜191(0)  : HSV形式 H値
	p2=0〜255(0)  : HSV形式 S値
	p3=0〜255(0)  : HSV形式 V値

	・説明

		色の指定をHSV形式で行ないます。ここで指定された色は、
		mes,pset,boxf命令などのグラフィック命令で使用されます。
		color命令のHSV形式版として使用してください。


・拡張画面操作命令

	grect p1,p2,p3,p4,p5,p6				回転する矩形で塗りつぶす
	p1=0〜(0)  : 矩形の中心X座標
	p2=0〜(0)  : 矩形の中心Y座標
	p3=0〜(0)  : 回転角度(4096=360度)
	p4=0〜(?)  : Xサイズ
	p5=0〜(?)  : Yサイズ
	p6=0〜(0)  : パレットコード

	・説明

		(p1,p2)で指定した座標を中心として、(p4,p5)で指定したサイズの
		矩形(長方形)を描画します。
		描画される色は、color命令またはpalcolor命令で指定されているものと
		なります。
		p3で回転角度を指定することができます。
		角度は、0から始まって、4096で一周(360度)します。
		grect命令は、gmodeで設定されたコピーモードの指定が反映されます。
		gmodeが0,1の場合は、通常の塗りつぶし。
		gmodeが3の場合は、指定されたレートで半透明になります。
		gmodeが5,6の場合は、それぞれ色加算、色減算処理となります。
		また、(p4,p5)のサイズ指定を省略した場合には、gmode命令で設定されている
		コピーサイズが使用されます。
		パレットモード時には、p6で指定したパレットコードで塗りつぶしが
		行なわれます。また、パレットモード時には半透明処理は実行されません。

	grotate p1,p2,p3,p4,p5,p6			矩形画像を回転してコピー
	p1=0〜(0)  : コピー元のウインドゥID
	p2=0〜(0)  : コピー元の左上X座標
	p3=0〜(0)  : コピー元の左上Y座標
	p4=0〜(0)  : 回転角度(4096=360度)
	p5=0〜(?)  : Xサイズ
	p6=0〜(?)  : Yサイズ

	・説明

		grotate命令は、gcopy命令に回転を含めた処理を行ないます。
		p1で、コピー元のウインドゥIDを指定、(p2,p3)でコピーされる元の画像
		にあたる座標を指定します。(gcopy命令と同様です)
		コピー先は、現在の描画先に指定されているウインドゥIDで、
		pos命令で設定された場所を中心とした座標にコピーを行ないます。
		その際に、p3で回転角度を指定することができます。
		角度は、0から始まって、4096で一周(360度)します。
		(p5,p6)で、コピーされた後のX,Yサイズを指定します。
		また、コピー元のX,Yサイズはgmode命令で設定されたデフォルトの
		コピーサイズが使用されます。
		つまり、gmode命令で指定されたサイズよりも大きなサイズを(p5,p6)
		で指定した場合には、拡大されることになります。
		(p5,p6)を省略した場合には、コピー元と同じサイズ、つまり等倍で
		コピーが行なわれます。

		grotate命令は、gmodeで設定されたコピーモードの指定がすべて
		反映されます。
		透明色の設定や、半透明の設定はすべてgcopy命令でコピーした場合と
		同等に機能します。(詳しくはgmode命令のリファレンスを参照)

		パレットモード時には半透明処理は実行されません。
		また、異なる画面モード(パレットモードとフルカラーモード)間での
		コピーはエラーになります。

	gsquare p1,p2,p3,p4,p5				任意の四角形画像をコピー

	p1=0〜(0)  : コピー元のウインドゥID (マイナス値ならば塗りつぶし)
	p2=変数名  : コピー先X座標が格納される数値型配列変数名
	p3=変数名  : コピー先Y座標が格納される数値型配列変数名
	p4=変数名  : コピー元X座標が格納される数値型配列変数名
	p5=変数名  : コピー元Y座標が格納される数値型配列変数名

	・説明

		任意の４点を持つ四角形をコピーまたは塗りつぶします。
		p1で、画像コピー元のウインドゥIDを指定します。
		p1に-1などマイナス値を指定した場合は、画像コピーではなく塗りつぶし
		が行なわれます。
		その際、フルカラーモード時にはcolor、palcolor命令で指定された
		色による塗りつぶしとなります。パレットモード時は、p1で指定した
		値-1をパレットコードとして塗りつぶしを行ないます。
		(-1〜-256がパレットコード0〜255に対応します)

		p2,p3にはコピー先の座標４つを配列に格納した変数を指定します。
		p4,p5にはコピー元の座標４つを配列に格納した変数を指定します。
		配列変数には、左上(0),右上(1),右下(2),左下(3)の順番に座標を
		入れておく必要があります。
		塗りつぶしを行なう場合には、(p4,p5)を指定する必要はありません。

		gsquare命令は、gmodeで設定されたコピーモードの指定がすべて
		反映されます。
		透明色の設定や、半透明の設定はすべてgcopy命令でコピーした場合と
		同等に機能します。(詳しくはgmode命令のリファレンスを参照)

		パレットモード時には半透明処理は実行されません。
		また、異なる画面モード(パレットモードとフルカラーモード)間での
		コピーはエラーになります。


・システム情報取得命令

	Windowsのシステム情報を取得するとための命令セットです。
	システム情報取得の他に、システムのシャットダウン、再起動、ログオフなどの
	通知を行なうことが可能です。

	sysexit p1					システムに終了を通知

	p1=0〜(0)  : 終了タイプ指定

	・説明

		動作中のWindowsシステムを終了させます。
		p1で指定されたタイプに従って、Windowsが終了します。
		この命令が実行されると、すべてのアプリケーションが終了処理を
		行ないます。作成中のスクリプトのセーブなど、十分注意して使用して
		ください。また、sysexit命令の後は、end命令を入れてHSPのスクリプト
		も終了させてください。
		p1で指定するタイプ指定は以下の通りです。

		   タイプ      内容
		-----------------------------------------------------------
			0          ログオフする
			1          再起動をする
			2          シャットダウンをする
			3          電源を切る

		電源を切る場合には、シャットダウン後に電源を切る指定を行なって
		ください。WindowsNTや2000、XPなどユーザー権限のあるOSでは、権限が
		ない場合に終了させることができない場合があります。


・簡易数学関数命令

	固定小数点を使用した数学関数をサポートするための命令セットです。
	これは現在の整数演算とともに使用できる、簡単な小数の演算をするための
	ものです。高精度な技術計算などには向きません。画面上での動きや、効果など
	ちょっとしたところに三角関数を使いたいというライトな用途に適しています。
	現在サポートされている関数は、サイン、コサイン、アークタンジェント、
	ルートの４つです。この他に、固定小数と整数との変換や、文字列への変換
	などがサポートされています。
	この命令セットで扱う固定小数は、通常の32bit整数を、整数部24bit+小数部8bit
	(デフォルトの設定。変更することも可能です)などに分割して使用しています。
	これにより、通常の整数とまったく同じように四則演算などの式を使用できます。
	たとえば、32bit整数で10という値は、24+8bitの固定小数では2560になります。
	簡易数学関数命令セットを使うことで、24+8bitの数を32bit整数に変換したり、
	小数点を含む形式で文字列に変換することが可能になります。


	emath p1				固定小数の精度を指定

	p1=2〜30(8)      : 固定小数のビット精度

	・説明

		簡易数学関数命令セット全体で使われる固定小数の精度を設定します。
		p1で精度のビット数を指定します。たとえば、16を指定すると
		「整数16bit + 小数16bit」のフォーマットになります。
		固定小数のビット精度が高いほど、誤差のない正確な小数点演算が可能
		になりますが、そのぶん整数部で扱える範囲がせまくなります。
		デフォルトでは8bitに設定されています。

	emstr p1,p2,p3				固定小数を文字列に変換

	p1=変数名  : 文字列が格納される文字列型変数名
	p2=0〜     : 固定小数の値
	p3=1〜(10) : 変換される文字列の桁数

	・説明

		固定小数の値を、小数点を含む文字列に変換します。
		p1で指定した文字列型変数に、変換後の文字列が代入されます。
		p2に、変換の対象になる固定小数の値(が代入されている変数)を指定
		します。p3で、変換される桁数を指定することができます。
		p3の指定を省略した場合は、10桁になります。

	emcnv p1,"val"				文字列を固定小数に変換

	p1=変数名  : 固定小数が格納される数値型変数名
	"val"      : 固定小数を示す文字列

	・説明

		"val"で指定した文字列を、固定小数の値に変換して、p1の変数に代入
		します。たとえば、"3.1415"という文字列を指定すると、それを固定小数
		に変換して格納します。

	emint p1,p2					固定小数を整数に変換

	p1=変数名  : 文字列が格納される文字列型変数名
	p2=0〜     : 固定小数の値

	・説明

		固定小数の値を、通常の32bit整数に変換し、p1で指定した数値型変数に代入
		します。整数に変換する際には、小数部分はすべて切り捨てられます。

	emsin p1,p2					サインを求める

	p1=変数名  : 結果が格納される数値列型変数名
	p2=0〜     : 角度(固定小数)

	・説明

		p2で指定した角度のサイン値を求めて、p1で指定された変数に代入します。
		p2の角度には、固定小数の値を指定します。単位は、0から始まって1.0で
		1回転する数値になっています。
		p2の値を32bit整数値として見ると、0から始まり、64で90度、128で180度、
		192で270度、256で360度となります(固定小数の精度が8bitの場合)。

	emcos p1,p2					コサインを求める

	p1=変数名  : 結果が格納される数値列型変数名
	p2=0〜     : 角度(固定小数)

	・説明

		p2で指定した角度のコサイン値を求めて、p1で指定された変数に代入します。
		p2の角度には、固定小数の値を指定します。単位は、0から始まって1.0で
		1回転する数値になっています。
		p2の値を32bit整数値として見ると、0から始まり、64で90度、128で180度、
		192で270度、256で360度となります(固定小数の精度が8bitの場合)。

	emsqr p1,p2					平方根を求める

	p1=変数名  : 結果が格納される数値列型変数名
	p2=0〜     : 固定小数

	・説明

		p2で指定した固定小数の平方根(ルート)を求めて、p1で指定された変数に代入
		します。p2にマイナスの値や0を指定した場合は、0が返されます。

	ematan p1,p2,p3				アークタンジェントを求める

	p1=変数名  : 結果が格納される数値列型変数名
	p2=0〜     : X値
	p3=0〜     : Y値

	・説明

		Y/Xのアークタンジェントを求めて、p1で指定された変数に代入します。
		これは、２点間の角度を求める場合に主に使用します。
		(X1,Y1)という座標と、(X2,Y2)の座標の角度を求める場合は、座標の差分、
		X値は(X2-X1)、Y値は(Y2-Y1)を指定します。
		p1に代入される角度の値は、emsinやemcos命令で使われる角度の単位
		(0から始まって、1.0で一回転)と同じです。


・レジストリ操作命令

	Windows95(NT)のレジストリ情報の読み書きを行なうための命令セットです。
	レジストリには、各種アプリケーションの設定が保存されているほか、
	Windows自体の動作設定もきめ細かく保存されている重要なデータです。
	レジストリ操作命令では、すべての情報にアクセスが可能ですが、間違った
	システム情報を書き込むと、最悪システムが動作しなくなるなどの深刻な事態を
	引き起こすので、レジストリの操作は慎重に行なうようにしてください。


	regkey p1,"key-name",p2				レジストリキー指定

	p1=0〜(0)  : キーグループ指定
	"key-name" : キー名指定
	p2=0〜1(0) : 既存のキー(0)・新規作成(1) モードスイッチ

	・説明

		アクセスするレジストリのキーを指定します。レジストリの読み書きを
		する場合には、最初に必ずregkey命令でキーと読み書きのモードを指定
		しておかなければなりません。
		p1では、キーグループを指定します。これは以下の中から選びます。

		    p1  key group
		  --------------------------------
		     0 : HKEY_CURRENT_USER
		     1 : HKEY_LOCAL_MACHINE
		     2 : HKEY_USERS
		     3 : HKEY_CLASSES_ROOT
			 4 : HKEY_DYN_DATA ( Windows95/98のみ )
			 5 : HKEY_PERFORMANCE_DATA ( WindowsNTのみ )

		"key-name"では、"Software\\OnionSoftware\\hsed"のように「\\」で
		ツリーを区切って階層指定を行ないます。
		最後に、p2で読み書きモードの設定をします。p2が0の場合は読み出し
		モードとなり、getreg命令で指定したセクションの内容を読み出す
		ことができるようになります。p2が1の場合は、新規作成モードとなり、
		setreg命令で指定したセクションを追加します。
		すでに存在するレジストリの読み出し、変更はp2を0に設定してください。
		regkey命令の実行後は、システム変数statに結果が返ります。
		システム変数statが0以外の場合は、何らかのエラーが起こっている
		ことを示しています。

	getreg p1,"section",p2,p3			レジストリ読み出し

	p1=変数名  : 読み出すための変数名
	"section"  : セクション名指定
	p2=0〜1(0) : タイプ指定
	p3=1〜(64) : 読み出しサイズ指定

	・説明

		指定されたセクションの内容をp1で指定した変数に読み出します。
		あらかじめregkey命令でアクセスするレジストリの位置を指定して
		から使う必要があります。対象となるレジストリ位置が指定されて
		いない時は、エラーが表示されます。
		p2でタイプを指定します、タイプのコードは以下の通りです。

		    p2  type code
		  --------------------------------
		     0 : 数値(32bit)
		     1 : 文字列
		     2 : バイナリデータ

		p3で読み出しサイズを指定します。これは、文字列かバイナリのタイプ
		を選んだ場合に有効になります。
		命令の実行後は、システム変数statに結果が返ります。
		システム変数statが0以外の場合は、何らかのエラーが起こっている
		ことを示しています。

	setreg p1,"section",p2,p3				レジストリ書き込み

	p1=変数名  : 書き込むための変数名
	"section"  : セクション名指定
	p2=0〜1(0) : タイプ指定
	p3=1〜(64) : 書き込みサイズ指定

	・説明

		p1で指定された変数の内容を、指定されたセクションに書き込みます。
		あらかじめregkey命令でアクセスするレジストリの位置を指定して
		から使う必要があります。対象となるレジストリ位置が指定されて
		いない時は、エラーが表示されます。
		p2でタイプを指定します、タイプのコードは以下の通りです。

		    p2  type code
		  --------------------------------
		     0 : 数値(32bit)
		     1 : 文字列
		     2 : バイナリデータ

		p3で書き込みサイズを指定します。これは、バイナリのタイプを選んだ
		時にのみ有効になります。
		命令の実行後は、システム変数statに結果が返ります。
		システム変数statが0以外の場合は、何らかのエラーが起こっている
		ことを示しています。

	regkill p1,"key-name"			レジストリキー削除

	p1=0〜(0)  : キーグループ指定
	"key-name" : キー名指定

	・説明

		指定したレジストリのキーを削除します。
		p1では、キーグループを指定します。これは以下の中から選びます。

		    p1  key group
		  --------------------------------
		     0 : HKEY_CURRENT_USER
		     1 : HKEY_LOCAL_MACHINE
		     2 : HKEY_USERS
		     3 : HKEY_CLASSES_ROOT
			 4 : HKEY_DYN_DATA ( Windows95/98のみ )
			 5 : HKEY_PERFORMANCE_DATA ( WindowsNTのみ )

		"key-name"では、"Software\\OnionSoftware\\hsed"のように「\\」で
		ツリーを区切って階層指定を行ないます。
		命令の実行後は、システム変数statに結果が返ります。
		システム変数statが0以外の場合は、何らかのエラーが起こっている
		ことを示しています。
		指定したレジストリのキーの下に、さらにキーが含まれている場合には
		注意が必要です。OSがWindowsNTの場合は、レジストリキーの下にさらに
		キーが含まれている場合にはエラーとなり削除できません。
		Windows95(98)/NTどちらでも動作するようなスクリプトを作る際には、
		この点に気をつけてください。

	reglist p1,p2					レジストリ一覧取得

	p1=変数名  : 読み出すための変数名
	p2=0〜1(0) : モード指定

	・説明

		指定された位置にあるレジストリキーの一覧を取得します。
		あらかじめregkey命令でアクセスするレジストリの位置を指定して
		おく必要があります。
		p2のモードが、0の時は「セクション一覧」を取得し、モード1の場合は、
		「キー一覧」を取得することになります。
		たとえば、"Software\\OnionSoftware\\hsed"と、
		"Software\\OnionSoftware\\hspcomm"という2つのレジストリキーが存在
		したとすると、"Software\\OnionSoftware"の位置から下にあるキー一覧
		は、「hsed」と「hspcomm」になります。
		これにより、レジストリツリーの中にどのようなキーやセクションが
		存在しているかを調べることができます。
		取得された情報は、p1で指定した文字列型の変数に代入されます。
		それぞれの項目は改行(\n)で区切られた形で取得されるので、あらかじめ
		十分な変数のバッファを取っておいた方が安全です。
		取得した文字列は、メモリノートパッド命令やlistbox命令、combox命令
		でそのまま使用することができます。


・シリアル通信命令

	シリアル(COM)ポートに接続された外部機器を制御するための命令セットです。
	通常は、モデムなどの通信機器とのやり取りに使われますが、他にもシリアル接続の
	イメージスキャナ、各種制御機器、またはリバース接続された別のコンピュータとの
	通信が可能です。また、プリンタポートにも同じ命令セットでアクセスが可能です。
	シリアル通信命令は、基本的な通信をサポートしているだけですので、高度な制御
	を行なうことはできません。シリアル通信命令では、同時に１つのポートまでしか
	制御できません。複数のシリアルポートを同時に監視するソフトを構築することは
	できませんのでご注意ください。
	シリアルポートは、一度初期化されると、開放するまで他のアプリケーションが
	使用できなくなってしまうので、必ず最後にポートを開放することを忘れないで
	ください。特に通信中にクローズボックスを押して終了してしまうことのないように
	onexit命令などで、終了時に注意を促すようなスクリプトを作成してください。


	comopen p1,"protocol"				シリアルポートを初期化

	p1=0〜(0)  : COMポート番号
	"protocol" : プロトコル指定文字列

	・説明

		シリアルポートを初期化して送受信を可能な状態にします。
		シリアル通信命令セットを使う場合には、最初にcomopen命令でポートの
		初期化をする必要があります。
		p1で、COMポートの番号を指定します。1ならばCOM1、2ならばCOM2…が対応
		します。p1が0の場合は、シリアルではなくプリンタ(パラレル)ポートが
		指定されます。
		"protocol"で、プロトコル指定文字列を記述することができます。
		プロトコル指定文字列は以下のような記述をする必要があります。

		"baud=1200 parity=N data=8 stop=1"

		上の例では、ボーレートが1200bps、パリティビットなし、データビット8、
		ストップビット1という指定になります。
		"protocol"に何も書かなかった場合(""を指定)は、現在のデフォルト値が
		使用されます。通常は、何も指定しなくても問題ありません。
		シリアルポートの初期化に成功すると、システム変数statの値が0になります。
		もし、初期化に失敗した場合はシステム変数statの値は1になります。


	comclose					シリアルポートを解放

	・説明

		シリアルポートとの通信を終了します。
		comopen命令で初期化されたシリアルポートは、必ずcomclose命令で最後に
		解放する必要があります。
		comclose命令でポートが解放されないままプログラムが終了すると、
		他のプログラムがポートに二度とアクセスできなくなってしまうので注意
		してください。

	computc p1					シリアルポートに送信

	p1=0〜255(0)  : 送信データ(1バイト)

	・説明

		p1で指定された1バイトの数値データをシリアルポートに送出します。
		命令の実行後、システム変数statに結果が返されます。
		システム変数statが0ならば、通信に失敗し送信されていないことを示します。

	comput "send-string"				シリアルポートに文字列送信

	"send-string" : 送出文字列

	・説明

		"send-string"で指定された文字列をシリアルポートに送出します。
		命令の実行後、システム変数statに結果が返されます。
		システム変数statが0ならば、通信に失敗し送信されていないことを示します。
		1以上の場合は、送信に成功したバイト数(文字数)が代入されています。

	comgetc p1					シリアルポートから受信

	p1=数値型変数 : 受信データが代入される変数名

	・説明

		シリアルポートから1バイト受信し、p1で指定した変数に代入します。
		命令の実行後、システム変数statに結果が返されます。
		システム変数statが0ならば、受信バッファが空になっていることを示して
		います。

	comget p1,p2					シリアルポートから文字列を受信

	p1=文字列型変数 : 受信データが代入される変数名
	p2=1〜(64)      : 受信文字数指定

	・説明

		シリアルポートから文字列を受信し、p1で指定した変数に代入します。
		p2で、受信する文字数を指定することができます。
		命令の実行後、システム変数statに結果が返されます。
		システム変数statが0ならば、受信バッファが空になっていることを示して
		います。
		受信に成功すると、p1に文字列が代入され、システム変数statに実際に
		受信した文字数が代入されます。


	comstat p1						シリアルポートの状態取得

	p1=数値型配列変数 : 状態データが代入される変数名

	・説明

		シリアルポートの状態を取得してp1で指定した変数に代入します。
		p1で指定する変数は、配列でp1.0〜p1.3までに以下の情報が代入されます。
		状態取得が正常に行なわれた場合にはシステム変数statが0になります。
		エラーが発生した場合には、システム変数statは1になります。

	-----------------------------------------------------------------------
	a.0
		エラー発生時に以下のエラーフラグの組み合わせが代入されます。

		CE_RXOVER           0x0001  受信バッファのオーバーフロー。 
		CE_OVERRUN          0x0002  オーバーランエラー。 
		CE_RXPARITY         0x0004  受信時のパリティエラー。 
		CE_FRAME            0x0008  フレーミングエラー。 
		CE_BREAK            0x0010  ブレーク状態。 
		CE_TXFULL           0x0100  送信バッファがいっぱいになりました。 
		CE_PTO              0x0200  タイムアウト。
		CE_IOE              0x0400  一般 I/O エラー。 
		CE_DNS              0x0800  デバイスが選択されていません。
		CE_OOP              0x1000  給紙切れエラー。
		CE_MODE             0x8000  サポート外のモードです。

	a.1
		以下のデバイス状態フラグが代入されます。

		bit0 fCtsHold  ON: 送信は CTS 待ち  
		bit1 fDsrHold  ON: 送信は DSR 待ち  
		bit2 fRlsdHold  ON: 送信は RLSD (CD) 待ち  
		bit3 fXoffHold  ON: XOFF を送信したため 送信は停止中  
		bit4 fXoffSent  ON: XOFF を送信したため 送信は停止中  
		bit5 fEof  ON: EOF を受信した  
		bit6 fTxim  ON: 送信バッファにデータが残っている  

	a.2
		cbInQue  受信バッファにあるデータのバイト数  
	a.3
		cbOutQue  送信バッファにあるデータのバイト数  
	-----------------------------------------------------------------------


	comcontrol p1					シリアルポートの特殊コントロール

	p1=1〜9(0)      : 特殊コントロール機能指定

		シリアルポートに対して特殊なコントロールを行ないます。
		p1で、コントロールする機能を以下の中から指定します。

		           値      機能
		-----------------------------------------------------------------------
		SETXOFF    1       XOFF 文字を受信したときのように送信を行います。
		SETXON     2       XON 文字を受信したときのように送信を行います。
		SETRTS     3       RTS（ 送信要求）信号を送信します。
		CLRRTS     4       RTS（ 送信要求）信号を消去します。
		SETDTR     5       DTR（ データ端末準備完了）信号を送信します。
		CLRDTR     6       DTR（ データ端末準備完了）信号を消去します。
		RESETDEV   7       デバイスをリセットします
		SETBREAK   8       文字送信を中断し、送信回線を切断状態にします。
		CLRBREAK   9       送信回線の切断状態を解除して、文字送信を再開します。

		状態取得が正常に行なわれた場合にはシステム変数statが0になります。
		エラーが発生した場合には、システム変数statは1になります。


・拡張ファイルアクセス命令

	HSP標準のファイル操作命令だけでは不可能だった、より高度なファイル操作、
	およびファイルシステムの情報を取得するための命令です。
	指定されたファイルやドライブの状態を取得、設定することが可能になります。


	fxcopy p1,"dest",p2				ファイルのコピー・移動

	p1=変数    : コピー元のファイル名が格納された文字列型変数名
	"dest"     : コピー先のパス名
	p2=0,1 (0) : モード指定( 0=コピー / 1=移動 )

	・説明

		指定したファイルを、別のパスにコピーまたは移動をします。
		p1で、コピー元のファイル名をあらかじめ格納してある変数名を指定します。
		"dest"で、コピー先のディレクトリやドライブを指定します。
		p2のモードにより、コピーか移動のどちらかを指定することができます。
		p2の指定を省略した場合は、コピーになります。
		移動のモードを指定した場合は、元のファイルは削除されます。ただし、
		移動は同一ドライブ内でなければなりません。

		例:
			a="test.bin"
			fxcopy a,"c:\\temp"		; "test.bin"をC:\tempにコピー

		fxcopy命令は、Windowsのシェルを使って高速にコピー・移動を行ないます。
		HSPのbcopy命令よりも高速ですが、packfileで指定したファイルへのアクセス
		はできませんので注意してください。
		命令の実行に失敗すると、システム変数statに1が代入されます。正常に終了
		した場合は、システム変数statは0になります。


	fxren  p1,"new name"			ファイル名を変更

	p1=変数    : オリジナルのファイル名が格納された文字列型変数名
	"new name" : 新規ファイル名

	・説明

		指定したファイルを、"new name"で指定したファイル名に変更します。
		p1で、元のファイル名をあらかじめ格納してある変数名を指定します。
		"new name"で、新しいファイル名を指定します。
		命令の実行に失敗すると、システム変数statに1が代入されます。正常に終了
		した場合は、システム変数statは0になります。


	fxinfo p1,p2,p3					ドライブ情報を取得

	p1=変数    : 情報が格納される変数名
	p2=0〜(0)  : ドライブ指定
	p3=0〜(0)  : 情報タイプ指定

	・説明

		p2で指定したドライブについての情報をp1で指定した変数に代入します。
		p2で指定するドライブは、0だとカレントドライブ、1ならばAドライブ、2ならば
		Bドライブ…というように1から26までが、A〜Zドライブに対応しています。
		p3で、情報タイプを指定することで様々なドライブ情報を取得することが
		できます。p3で指定できる数値は以下の通りです。

		   p3   変数型     情報の内容
		  --------------------------------
		   0  : 数値型   : ドライブの残り容量(byte)
		   1  : 数値型   : 1クラスタあたりのセクタ数
		   2  : 数値型   : 1セクタあたりのバイト数
		   3  : 数値型   : 空きクラスタ数
		   4  : 数値型   : トータルのクラスタ数
		   8  : 数値型   : ドライブのタイプ
		   16 : 文字列型 : ボリュームラベル名
		   17 : 文字列型 : ファイルシステム名
		   18 : 数値型   : ボリュームシリアル番号
		   19 : 数値型   : 使用可能な最大ファイル文字数
		   20 : 数値型   : ファイルシステムフラグ
		   32 : 文字列型 : ドライブの残り容量(byte) (大容量対応)

		指定するタイプにより、p1の変数に代入される型が違います。タイプ16,17は
		あらかじめ文字列型の変数を指定しなければなりません。
		タイプ8で取得できるドライブのタイプ値の詳細は以下の通りです。

		  タイプ   内容
		  --------------------------------
		    0    : 不明なドライブ
		    1    : ドライブなし
		    2    : リムーバブルディスク
		    3    : ハードディスク
		    4    : リモート(ネットワーク)ドライブ
		    5    : CD-ROMドライブ
		    6    : RAMディスク

		命令の実行に失敗すると、システム変数statに1が代入されます。正常に終了
		した場合は、システム変数statは0になります。

		p3に0を指定して得られるドライブの残り容量は、2Gbyteまでの値と
		なります。2Gを超える値の場合はp3に32を指定して文字列としてサイズを
		得る方法をご使用下さい。


	fxaget p1,"file"				ファイル属性を取得

	p1=変数名 : 情報が格納される数値型変数名
	"file"    : ファイル名指定

	・説明

		"file"で指定したファイルの属性を読み出し、p1で指定した変数に代入します。
		読み出した属性は以下のような数値が含まれています。

		   属性     内容
		  --------------------------------
		      $1  : 書き込み禁止
		      $2  : 隠しファイル
		      $4  : システム
		     $10  : ディレクトリ
		     $20  : アーカイブ
		     $80  : 標準タイプ
		    $100  : 一時ファイル
		    $800  : 圧縮ファイル
		   $1000  : オフライン

		同時に複数の属性が設定されている場合は、それぞれの値を足した値になります。
		命令の実行に失敗すると、システム変数statに1が代入されます。正常に終了
		した場合は、システム変数statは0になります。


	fxaset "file",p1				ファイル属性を設定

	"file"    : ファイル名指定
	p1=0〜(0) : 設定する属性

	・説明

		"file"で指定したファイルに、p1で指定した属性を設定します。
		p1で指定する属性値は以下のような数値が使用できます。

		   属性     内容
		  --------------------------------
		      $1  : 書き込み禁止
		      $2  : 隠しファイル
		      $4  : システム
		     $10  : ディレクトリ
		     $20  : アーカイブ
		     $80  : 標準タイプ
		    $100  : 一時ファイル
		    $800  : 圧縮ファイル
		   $1000  : オフライン

		同時に複数の属性を設定する場合は、それぞれの値を足した値にしてください。
		命令の実行に失敗すると、システム変数statに1が代入されます。正常に終了
		した場合は、システム変数statは0になります。


	fxtget p1,"file"				タイムスタンプを取得

	p1=変数名 : 情報が格納される数値型の配列変数名
	"file"    : ファイル名指定

	・説明

		"file"で指定したファイルのタイムスタンプ情報を取得して、p1で指定した
		変数に代入します。ただし、p1の変数は配列変数、数値型で24以上の要素を
		入れるだけのメモリ確保をしておかなければなりません。
		このためfxtgetおよび、fxtset命令で指定する変数はあらかじめdim命令で、
		「dim a,24」などの配列宣言をしてから使用してください。
		取得されたタイムスタンプの情報は配列変数の各要素に代入されます。
		たとえば、「fxtget a,"test"」と指定した場合は、変数a.0〜a.23に情報が
		代入されます。配列の各要素に代入される値の詳細は以下の通りです。

		   要素    内容
		  --------------------------------
		    0    : 作成日の年(西暦)
		    1    : 作成日の月
		    2    : 作成日の曜日(日曜=0)
		    3    : 作成日の日
		    4    : 作成日の時
		    5    : 作成日の分
		    6    : 作成日の秒
		    7    : 作成日のミリ秒
		  --------------------------------
		    8    : 更新日の年(西暦)
		    9    : 更新日の月
		   10    : 更新日の曜日(日曜=0)
		   11    : 更新日の日
		   12    : 更新日の時
		   13    : 更新日の分
		   14    : 更新日の秒
		   15    : 更新日のミリ秒
		  --------------------------------
		   16    : 最終アクセス日の年(西暦)
		   17    : 最終アクセス日の月
		   18    : 最終アクセス日の曜日(日曜=0)
		   19    : 最終アクセス日の日
		   20    : 最終アクセス日の時
		   21    : 最終アクセス日の分
		   22    : 最終アクセス日の秒
		   23    : 最終アクセス日のミリ秒
		  --------------------------------

		命令の実行に失敗すると、システム変数statに1が代入されます。正常に終了
		した場合は、システム変数statは0になります。


	fxtset p1,"file"				タイムスタンプを設定

	p1=変数名 : 設定する情報が格納されている数値型の配列変数名
	"file"    : ファイル名指定

	・説明

		"file"で指定したファイルのタイムスタンプ情報を、p1で指定した変数の
		ものに変更します。ただし、p1の変数は配列変数、数値型で24以上の要素を
		入れるだけのメモリ確保をしておかなければなりません。
		p1で指定する配列変数は、fxtget命令で使用するものと同一形式です。
		配列変数に指定する値の詳細は、fxtget命令の説明を参照してください。
		命令の実行に失敗すると、システム変数statに1が代入されます。正常に終了
		した場合は、システム変数statは0になります。

		fxtset命令で設定するタイムスタンプは、OSのファイルシステムによっては
		完全に設定されないことがあります。これは、ファイルシステムが完全な
		形で時間を保存していないためです。たとえば、Windows95(FAT)の場合は、
		最終アクセス日の時刻は記録されません。日付のみになります。また秒単位の
		データも粗く記録されます。


	selfolder p1,"message"			フォルダ選択ダイアログ

	p1=変数名 : 選択されたパス名が格納される文字列型の変数名
	"message" : ダイアログに表示される文字列

	・説明

		Windowsのシステムで使用されている、フォルダ選択ダイアログを表示して、
		フォルダ名を取得します。
		選択が正常に終了すると、システム変数statには0が代入されます。
		選択時にエラーまたは、キャンセルされた場合には、システム変数statの
		値は1になります。
		正常に選択された場合には、フォルダまでのフルパス名がp1で指定した変数に
		代入されます。また、フォルダ名がシステム変数refstrに代入されます。
		"message"の部分に、ダイアログ表示の時に上に表示される文字列を指定する
		ことができます。指定を「""」にすると、「フォルダを選択してください」
		という標準的なメッセージが表示されます。


	fxshort p1,"file"				DOSファイルネームを取得

	p1=変数名 : 情報が格納される文字列型変数名
	"file"    : ファイル名指定

	・説明

		"file"で指定したファイルをDOSファイルネームに変換して、p1で指定した
		変数に代入します。
		"file"に指定するファイル名は、Windowsで使われているロングファイル
		ネームでなければなりません。
		DOSプロンプトのアプリケーションなどに渡すためのファイル名を取得する
		場合などに使用できます。


	fxdir p1,p2						特殊なディレクトリ名を取得

	p1=変数名 : 情報が格納される文字列型変数名
	p2=0〜(0) : 取得するディレクトリ情報の種類

	・説明

		p2で指定した種類のディレクトリ名を、p1で指定した変数に代入します。
		この命令で、Windowsのシステムで使用される色々なディレクトリ名を取得
		することができます。
		p2で指定できる数値は以下の通りです。

		   p2     取得される内容
		  ------------------------------------------------------------
		  -2    : Windowsのテンポラリ(一時)フォルダ
		  -1    : Windowsのシステム(System)フォルダ
		   2    : スタートメニュー「プログラム」グループのフォルダ
		   5    : 「マイドキュメント」のフォルダ
		   6    : 「お気に入り」のあるフォルダ
		   7    : 「スタートアップ」フォルダ
		   8    : 「最近使った書類」フォルダ
		   9    : 「送る」(SendTo)のフォルダ
		   11   : スタートメニューのフォルダ
		   16   : デスクトップのフォルダ
		   21   : テンプレート(Template)フォルダ
		   26   : ApplicationDataフォルダ
		   27   : プリンタデバイスフォルダ
		   32   : Internet キャッシュフォルダ
		   33   : Internet Cookiesフォルダ
		   34   : Internet 履歴フォルダ

		指定に誤りがあったり、エラーが発生するとシステム変数statに
		1が代入されます。正常に終了するとシステム変数statは0になります。


	fxlink p1,"path"				ショートカットを作成

	p1=変数名 : ショートカット名が格納されている文字列型変数名
	"path"    : 元になるファイルのフルパス名

	・説明

		p2で指定したファイルへのショートカットを、p1で指定された名前で
		カレントディレクトリに作成します。
		p1に指定するのは、ショートカット名が格納された文字列型の変数で
		なければなりません。また、ショートカット名には拡張子やドライブ、
		ディレクトリ名を含まない形で指定してください。
		(エクスプローラーでは表示されませんが、自動的に拡張子が.lnkに
		なります)
		p2には、ショートカット先の場所をフルパスで指定してください。
		また、p2に「http://www.onionsoft.net/hsp/」などのURLを指定する
		と、インターネット・ショートカットが作成されます。

		指定に誤りがあったり、エラーが発生するとシステム変数statに
		1が代入されます。正常に終了するとシステム変数statは0になります。


	lzdist "path"					圧縮解凍先ディレクトリ指定

	"path" :lzcopy命令の解凍コピー先ディレクトリ

	・説明

		lzcopy命令の解凍コピー先ディレクトリを指定します。
		lzcopy命令を実行する場合は、必ずlzdist命令でコピー先をあらかじめ
		指定しておく必要かあります。


	lzcopy "name"					圧縮解凍コピー

	"name" :圧縮ファイル名

	・説明

		Microsoftのcompress.exe形式の圧縮ファイルを解凍しながらコピーを
		行ないます。
		カレントディレクトリにある"name"で指定された圧縮ファイルを、
		lzdist命令で指定したディレクトリに解凍された形でコピーします。
		"name"には、拡張子を含まない名前(8文字まで)を指定してください。
		lzcopy命令を実行する場合は、必ずlzdist命令でコピー先をあらかじめ
		指定しておく必要かあります。

		指定に誤りがあったり、エラーが発生するとシステム変数statに
		1が代入されます。正常に終了するとシステム変数statは0になります。


	dirlist2 p1,"filemask",p2,p3		拡張ディレクトリ取得

	p1=変数名  : ディレクトリ情報全体のサイズ
	"filemask" : 一覧のためのファイルマスク
	p2=0〜(0)  : 取得モード
	p3=0〜(0)  : ディレクトリ区切り記号

	・説明

		ディレクトリの情報を取得します。
		標準命令のdirlistよりもさらに詳しく検索することができます。
		dirlist2命令は、3つのステップで処理が完了します。

			1.dirlist2h命令で取得するものを選択
					↓
			2.dirlist2命令で取得を開始
					↓
			3.dirlist2r命令で結果を取得

		dirlist2命令は、決められたモードでディレクトリ情報の取得を行ない
		ます。結果は、dirlist2r命令で取得することができます。
		dirlist2命令が正常に終了した場合には、システム変数statに情報を
		取得したファイルの合計数が代入されます。
		取得モードの詳細は以下の通りです。

		"filemask"は、dirlist命令と同様に「*.*」のようなワイルドカード
		指定による検索ファイル名となります。

		p3で、取得時のディレクトリ区切り記号を指定することが可能です。
		0か、省略をした場合は「\」が使用されます。

		モードの値は、合計して組み合わせることが可能です。
		モード1(bit0)を指定した場合には、カレントディレクトリ以下すべての
		ディレクトリを再帰検索してファイル情報を取得します。

		 モード     取得される内容
		---------------------------------------------------------------
		 0       カレントディレクトリ以下のすべてのファイル一覧
		 1       カレントディレクトリのファイル一覧
		 2       隠しファイル、システム属性ファイルを一覧に含めない


	dirlist2h p1,p2			拡張ディレクトリ取得設定

	p1=0〜(0)  : 一覧リストフラグ
	p2=0〜(0)  : リスト区切り記号

	・説明

		dirlist2命令によるディレクトリの情報取得の詳細を設定します。
		実際の情報取得の方法については、dirlist2命令の説明を参照してください。

		p1の一覧リストフラグにより指定された項目が、区切り記号により分けられ
		テキスト情報として取得できるようになります。
		一覧リストフラグは、以下の通りです。

	    フラグ     取得される内容
	    -----------------------------------------------------------------
		   1       フルパスによるファイル名
		   2       パス名を除いたファイル名
		   4       ファイルのサイズ
		   8       ファイルの更新日付
		  16       ファイルの更新時間
		 128       パス名のみ

		フラグ値は、加算して組み合わせることができます。
		p1が0か省略された場合は、すべてのフラグを指定したことになります。
		p2でリストを区切る記号を指定することができます。
		p2が0か省略された場合は、「,」が指定されます。


	dirlist2r p1		拡張ディレクトリ取得2

	p1=変数名  : ディレクトリ情報を取得する変数

	・説明

		dirlist2命令により取得された情報を変数に代入します。
		必ずdirlist2命令で返されたサイズ以上のメモリが確保されている変数に
		対して実行する必要があります。
		実際の情報取得の方法については、dirlist2命令の説明を参照してください。


・クリップボードアクセス命令

	Windowsのクリップボードにデータを転送、または取得するための命令です。
	クリップボードに、テキストや画像データを送ることにより、他のアプリケーション
	とのデータ交換が容易になります。


	clipset "strings"				クリップボードテキスト転送

	"strings"     : クリップボードに送る文字列

	・説明

		"strings"で指定した文字列を、クリップボードに送ります。
		クリップボードに送られたテキストデータは、他のアプリケーション
		で貼り付け(ペースト)が可能になります。


	clipsetg					クリップボード画像転送

	・説明

		現在選択されている画面をビットマップデータとして、クリップボードに
		送ります。クリップボードに送られた画像データは、他のアプリケー
		ションで貼り付け(ペースト)が可能になります。


	clipget p1,p2					クリップボードテキスト取得

	p1=変数    : 情報が格納される変数名
	p2=0〜(64) : 最大文字数

	・説明

		クリップボードに送られているテキストの内容を読み出し、
		p1で指定した文字列型変数に代入します。
		読み出す内容は、他のアプリケーションなどでコピーされた
		テキストのみです。画像や音声は取り出すことができません。
		p2が省略されている場合は最大64文字まで読み出します。
		64文字以上の文字列を読み出す場合は、p2に最大文字数を指定して
		ください。(あらかじめ読み出す変数に十分なバッファが確保されて
		いる必要があります)


・アプリケーションキャプチャー命令

	アプリケーションキャプチャー命令は、Windows上で動作しているすべての
	オブジェクトの情報を取得したり、メッセージを送信することのできる非常に
	強力な命令群です。
	これにより、HSPから他のアプリケーションの動作をコントロールすることが
	できるようになります。
	詳しい使い方は、「アプリケーションキャプチャー命令の使い方」の項を
	参照してください。

	aplsel "window name",p1				任意のウインドゥ捕獲

	"window name" : 取得するウインドゥのタイトル名
	p1=0〜(0)     : 開始ID

	・説明

		指定したウインドゥを捕獲して、メッセージを送信する準備をします。
		"window name"に、ウインドゥのタイトルに表示されている文字列を
		指定することで、ウインドゥを検索します。
		"window name"は、終わりの文字列を省略することが可能です。
		たとえば、"ＨＳＰスクリプトエディタ" という名前のウインドゥは、
		"ＨＳＰ"だけでも、"ＨＳＰスクリ"という文字列でもマッチします。
		ただし、同じ名前のタイトルがあった場合には、どのウインドゥが
		マッチするかは不明になります。
		p1で、開始IDを指定することで検索を開始する検索IDを決める
		ことができます。この検索IDは、すべてのウインドゥ(およびタスク)
		のID番号で、0から順番に値がつけられています。
		「aplsel "",p1」と記述すると、検索IDがp1のウインドゥを捕獲する
		ことができます。
		aplsel命令が実行されて、ウインドゥの検索に成功した場合は、
		システム変数statに0が代入されて、システム変数refstrに正確な
		ウインドゥタイトル名が代入されます。
		ウインドゥの検索に失敗した場合は、システム変数statに1が代入され、
		メッセージの送信を行なうことはできません。


	aplobj "object name",p1				任意のオブジェクト捕獲

	"object name" : 取得するオブジェクトのクラス名
	p1=0〜(0)     : 開始オブジェクトID

	・説明

		aplsel命令で捕獲したウインドゥに属するオブジエクト(コントロール)
		を捕獲して、メッセージを送信する準備をします。
		"object name"に、オブジェクト(コントロール)のクラス名を指定する
		ことで、オブジェクトを検索します。
		p1で、開始IDを指定することで検索を開始する検索オブジェクトIDを
		決めることができます。このIDは、0から順番に値がつけられています。
		「aplsel "",p1」と記述すると、オブジェクトIDを捕獲することができ
		ます。
		aplobj命令が実行されて、オブジェクトの検索に成功した場合は、
		システム変数statに0が代入されて、システム変数refstrに正確な
		オブジェクトのクラス名が代入されます。
		ウインドゥの検索に失敗した場合は、システム変数statに1が代入され、
		メッセージの送信を行なうことはできません。


	aplact						ウインドゥをアクティブにする

	・説明

		aplsel命令、およびaplobj命令で捕獲したウインドゥをアクティブに
		して、キーボード入力が可能な状態にします。
		aplkey命令などで、HSP以外のウインドゥにキーを送信する場合には、
		aplact命令で、ウインドゥをアクティブにしておく必要があります。


	aplfocus					キー送信先をデフォルトにする

	・説明

		キー送信の対象となるウインドゥをデフォルトに戻します。
		デフォルト設定では、現在アクティブなウインドゥの、キーボード
		入力フォーカスがあるオブジェクトに対してキー送信されます。


	aplstr "strings"				文字列をキー送信

	"strings" : キー送信する文字列

	・説明

		"strings"で指定した文字列を、キーボード入力データとして、
		捕獲先のオブジェクトに送信します。
		aplstr命令は、文字列をそのまま送信することができますが、
		[ALT]キーなどの特殊キーの情報は送信できません。
		aplstr命令は、キーの情報をキューにためるだけです。
		実際に押した結果を反映するためには、waitやawait命令を後に
		入れる必要があります。一度に大量の情報を送りすぎると、キューが
		あふれてうまく送信されなくなる可能性があります。
		aplstr命令は、すべてのアプリケーションにおいて認識されるとは
		限りません。aplstr命令の送信を受け付けない場合は、aplkey命令
		などで試してみてください。


	aplkey p1,p2					キーコード送信

	p1=0〜(0) : キーコード
	p2=0〜(0) : 特殊キーコード
	            ( 1 = SHIFT / 2 = CTRL / 4 = ALT )

	・説明

		キーを押した情報を捕獲先のオブジェクトに送信します。
		p1で、キーコードを指定します。これは、getkey命令で使用している
		キーコードと同一のものです。(下の表を参照)
		p2で、特殊キーの指定をします。1ならば、シフトキー、2ならば
		CTRLキー、4ならばALTキーが同時に押されていることになります。
		aplkey命令は、キーの情報をキューにためるだけです。
		実際に押した結果を反映するためには、waitやawait命令を直後に
		入れる必要があります。
		p1に0を指定した場合には、特殊キーコードの情報のみが送信されます。

		キーコード一覧
		------------------------------------------
		        3 = キャンセル（[CTRL]+[BREAK]）
		        4 = ３ボタンマウスのまん中のボタン
		        8 = [BACKSPACE]（PC98の[BS]）
		        9 = [TAB]
		       13 = [ENTER]
		       16 = [SHIFT]
		       17 = [CTRL]
		       18 = [ALT]（PC98の[GRPH]）
		       20 = [CAPSLOCK]
		       27 = [ESC]
		       32 = スペースキー
		       33 = [PAGEUP]（PC98の[ROLLDOWN]）
		       34 = [PAGEDOWN]（PC98の[ROLLUP]）
		       35 = [END]（PC98の[HELP]）
		       36 = [HOME]（PC98の[HOMECLR]）
		       37 = カーソルキー[←]
		       38 = カーソルキー[↑]
		       39 = カーソルキー[→]
		       40 = カーソルキー[↓]
		------------------------------------------
		  48〜57  = [0]〜[9]（メインキーボード）
		  65〜90  = [A]〜[Z]
		  96〜105 = [0]〜[9]（テンキー）
		 112〜121 = ファンクションキー [F1]〜[F10]
		------------------------------------------


	aplkeyd p1,p2					キー押し下げ送信

	p1=0〜(0) : キーコード
	p2=0〜(0) : 特殊キーコード
	            ( 1 = SHIFT / 2 = CTRL / 4 = ALT )

	・説明

		キーを押した情報を捕獲先のオブジェクトに送信します。
		p1で、キーコードを指定します。これは、getkey命令で使用している
		キーコードと同一のものです。
		p2で、特殊キーの指定をします。1ならば、シフトキー、2ならば
		CTRLキー、4ならばALTキーが同時に押されていることになります。
		aplkey命令とは違い、aplkeyd命令は、キーを押した情報だけを送信
		します。キーを押しつづけたい場合や、当時に複数のキーを押した
		状態をつくりだしたい時に使用してください。
		また、aplkeyd命令でキーを押した情報を送信した後は、必ずキーを
		離したという情報をaplkeyu命令で送信しなければなりません。
		aplkeyd命令は、キーの情報をキューにためるだけです。
		実際に押した結果を反映するためには、waitやawait命令を直後に
		入れる必要があります。
		p1に0を指定した場合には、特殊キーコードの情報のみが送信されます。


	aplkeyu p1,p2					キー押し上げ送信

	p1=0〜(0) : キーコード
	p2=0〜(0) : 特殊キーコード
	            ( 1 = SHIFT / 2 = CTRL / 4 = ALT )

	・説明

		キーを離した情報を捕獲先のオブジェクトに送信します。
		p1で、キーコードを指定します。これは、getkey命令で使用している
		キーコードと同一のものです。
		p2で、特殊キーの指定をします。1ならば、シフトキー、2ならば
		CTRLキー、4ならばALTキーが同時に押されていることになります。
		aplkeyu命令は、キーを離した情報だけを送信します。
		必ず、aplkeyd命令と対にして使用してください。
		p1の指定を省略すると、aplkeyd命令で指定したキーコードと、特殊
		キーコードと同じものが使われます。
		aplkeyu命令は、キーの情報をキューにためるだけです。
		実際に押した結果を反映するためには、waitやawait命令を直後に
		入れる必要があります。


	aplget p1,p2					オブジェクトの文字列を取得

	p1=変数    : オブジェクトの文字列を読み出す変数名
	p2=0〜(64) : 最大文字数

	・説明

		aplobj命令で選択されたオブジェクトに設定された文字列を取得
		します。オブジェクトが"BUTTON"などの場合はそこに設定されて
		いる文字列が、またウインドゥの場合はタイトルに表示されている
		文字列を読み出します。
		p2が省略されている場合は最大64文字まで読み出します。
		64文字以上の文字列を読み出す場合は、p2に最大文字数を指定して
		ください。(あらかじめ読み出す変数に十分なバッファが確保されて
		いる必要があります)
		aplfocus命令で、ウインドゥの指定がデフォルトになっている場合は
		現在アクティブなウインドゥのタイトル文字列が読み出されます。
		aplget命令で"EDIT"オブジェクトの編集内容を呼び出すことは
		できません。"EDIT"オブジェクトの編集内容以外の情報は、
		apledit命令で取得することが可能です。


	apledit p1,p2,p3				エディットコントロール情報取得

	p1=変数    : 情報が格納される数値型変数名
	p2=0〜2    : 取得情報No.
	p3=0〜     : 行インデックス指定

	・説明

		aplobj命令で選択された"EDIT"タイプのオブジェクトの情報を取得
		します。p1に読み出す先の変数名を指定して、p2で情報の種類を
		指定します。

		p2=0 : 現在のカーソル位置(1byte単位)
		p2=1 : 全体の行数
		p2=2 : p3で指定した行にある文字数

		パラメータp3は、p2に2が指定された時のみ意味を持ちます。
		また、p2が0の時(カーソル位置取得)はp1で指定した変数に、先頭
		からカーソルまでのバイト数、もし選択範囲があれば、システム変数
		statにカーソル位置から選択されている範囲のバイト数が代入
		されます。

		(文字数は、WindowsXPのコモンコントロール6.0使用時はUnicode単位となります。)


	pipeexec p1,"filename",p2			パイプ付き実行

	p1=変数    : 標準出力が格納される文字列型変数名
	"filename" : 実行されるファイル名
	p2=0〜1(0) : ウインドゥ表示スイッチ

	・説明

		"filename"で指定したファイルを実行します。
		実行ファイルは、パイプを通じて標準入力、標準出力の設定取得
		が可能になります。
		pipeexec命令は、おもにwin32コンソールアプリケーション(DOS
		プロンプトで動作する32bitアプリケーション)の実行を支援する
		ための機能です。加えて、16bitアプリケーションおよび、バッチ
		ファイルは指定できないので注意してください。

		"filename"で実行ファイルを指定します。フルパス指定でない
		場合は、標準の検索パスが使用されます。
		コマンドラインオプションを指定する場合は、ファイル名に続いて
		DOSプロンプトの要領で指定してください。
		(例:「notepad.exe readme.txt」)

		p1で指定した変数バッファに、実行時の標準出力が格納されます。
		あらかじめ「sdim buf,32000」などで大きいバッファを確保した
		ものを指定するようにしてください。
		p2でウインドゥの表示ON/OFFを指定します。デフォルトでは、
		0(表示しない)になります。
		pipeexec命令実行後は、必ずpipegetでプロセス終了までを監視
		してください。


	pipeget p1					パイプ付き実行監視

	p1=変数    : 結果が格納される文字列型変数名

	・説明

		pipeexec命令で実行されたプロセスを監視します。
		p1に、パイプの情報を取得するバッファとなる文字列型変数を
		指定する必要があります。
		pipeexecによるファイル実行の状況は、システム変数statに
		返されます。

		    stat値   |      内容          |  変数p1の内容
		---------------------------------------------------------
		       0     |  実行終了          | 変化なし
		       1     |  実行準備中        | 変化なし
		       2     |  StdOutputを取得中 | StdOutput
		       3     |  StdErrorを取得中  | StdError
		       4     |  終了処理中        | 変化なし

		通常は、pipeexec命令の実行後はpipeget命令でstat値が0になる
		(実行終了)までwait/await命令を入れながら監視を続けて下さい。

		    例:

			sdim ln,4096
			sdim buf,32000

			pipeexec buf,"notepad.exe",1
			if stat : dialog "実行できませんでした" : end

			mes "実行中..."

			repeat
			pipeget ln		; パイプの取得/更新
			if stat=0 : break	; 実行終了ならループを抜ける
			wait 10
			loop

			mes "実行完了..."
			mes buf

			stop

		１回の実行で取得されるサイズは、p1で指定される文字列型の
		変数が確保しているバッファサイズまでになりますので、
		バッファが溢れることはありません。
		通常4096文字程度のバッファを割り当てるようにしていれば問題は
		ないでしょう(例:「sdim buf,4096」)。


	pipeput p1					パイプに1byte送る

	p1=0〜255(0)  : 送信コード

	・説明

		pipeexec命令で実行中のプロセスに対して、p1で指定した
		コードを標準入力として送ります。


・アプリケーションキャプチャー命令の使い方

	アプリケーションキャプチャーは、Windows上で動作している他のアプリケーション
	をHSPから操作するための命令セットです。
	アプリケーションキャプチャー命令は、Windows上のすべてのオブジェクトに
	メッセージを送信することが可能です。
	これにより、より細かい動作のバッチ処理や、ランチャーとしての応用範囲が
	さらに広がります。

	今回のバージョンでは、指定したオブジェクトへのキー入力送信、固定メッセージ
	送信が可能です。
	将来的には、マウスの移動やクリックなどの多くのメッセージを送信可能にする
	予定です。

	*現在、アプリケーションキャプチャー命令で、他のウインドゥに日本語の
	 メッセージを送信する場合Windows NTおよび2000ではUnicodeに変換される
	 ため正常に動作しないことがあります。ご了承下さい。

	キー入力送信を使うことにより、キーボードからの入力がないのに、入力された
	時と同じ状態をつくりだすことができます。キーを押した情報を、HSPのスクリプト
	から送り出すことができるわけです。
	ためしにサンプルスクリプトの「aplkey.as」や「aplkey2.as」を実行してみて
	ください。自分では何も入力していないのに、勝手にメモ帳のアプリケーションが
	動き出し、テキストを打ち始め、ファイルをロードします。
	また、HSPスクリプトエディタを勝手に動作させてしまうサンプルもあるはずです。
	このように誰かが、操作しているようにも見える自動運転をおこなうことができる
	機能が、アプリケーションキャプチャーなのです。

	アプリケーションキャプチャーはまた、Windowsで動作しているタスクやウインドゥ
	のすべてを割り出したり、アプリケーションが二重に起動していないかなどを
	調べることも可能です。

	アプリケーションキャプチャーを使う際には、最低限Windowsの動作原理を知って
	おく必要があります。と言ってもHSPのスクリプトの基本がわかっていれば、
	そんなに難しいものではありません。
	まず、サンプルスクリプトの「aplkey3.as」をためしに実行してみてください。
	Windowsでは、同時にウインドゥや、目には見えないタスクが多数実行されています。
	目に見えるウインドゥには、たいていタイトルバーがあり何らかの文字列が
	表示されています。「aplkey3.as」では、このウインドゥとタスクの一覧を上の
	リストボックスに表示しています。HSPのウインドゥも、スクリプトエディタの
	ウインドゥも表示されていると思います。
	そして、Windowsではこれらのウインドゥの１つ１つにまた子供のウインドゥとして
	いくつものオブジェクトが従属しています。HSPではbutton命令や、mesbox命令などで
	オブジェクトを画面上に配置していきますが、同じように他のソフトでもウインドゥ
	上に色々なオブジェクトを配置しています。
	「aplkey3.as」の一覧の中で、スクリプトエディタを選んで[CHECK]ボタンを押して
	みると、そこに従属するオブジェクト(Windowsではコントロールとも呼ばれます)の
	一覧が下のリストボックスに表示されます。
	このようにWindowsでは、ウインドゥとそれに付属するオブジェクトがすべてシステム
	で同じように管理されています。これらのオブジェクトに、直接メッセージを送る
	ことで、そのアプリケーションをコントロールすることが可能なのです。

	実際に、アプリケーションキャプチャー命令を使う場合の例を説明しましょう。
	おおまかな流れとしては、下のような手順になります。

	１．操作するウインドゥを選ぶ(aplsel命令)
	２．操作するウインドゥに従属するオブジェクトを選ぶ(aplobj命令)
	３．操作先のウインドゥをアクティブにする(aplact命令)
	４．キー入力送信を行なう(aplkey命令、aplstr命令)

	まず、aplsel命令で操作先のウインドゥを選びます。ウインドゥを選ぶ場合は、
	タイトルに表示されている文字列でウインドゥを検索します。
	タイトルが長い場合などは、最初の何文字かを指定するだけで検索をしてくれます。
	たとえば、「ＨＳＰスクリプトエディタ」というウインドゥを選びたいときには、

		aplsel "ＨＳＰスクリプトエディタ"

	と記述することで検索されます。最初の文字列だけで後を省略して、

		aplsel "ＨＳＰ"

	や、

		aplsel "ＨＳＰスク"

	のように記述することも可能です。ただし、同じ名前のウインドゥが複数ある
	場合には、どれがマッチするかはわかりません。

	ウインドゥを選んだら次に、それに従属するオブジェクトをaplobj命令で選びます。
	これは、それぞれのアプリケーションごとにどんなオブジェクトを使用している
	かで異なります。中にはオブジェクトを持たないアプリケーションもあります。
	その時は、aplobj命令でオブジェクトを選ぶ必要はありません。
	aplobj命令は、クラス名でオブジェクトを検索します。クラス名とは、オブジェ
	クトの種類を示す文字列です。サンプルスクリプトの「aplkey3.as」でそれぞれの
	ウインドゥが使用しているオブジェクトのクラス名一覧を見ることができますが、
	だいたいは以下のような名前が使われます。

		--------------------------------------
		| Edit         | 入力ボックス        |
		| Button       | 押しボタン          |
		| ListBox      | リストボックス      |
		| ComboBox     | コンボボックス      |
		| Static       | 固定テキスト        |
		| ScrollBar    | スクロールバー      |
		| MDIClient    | MDIの子ウインドゥ   |
		--------------------------------------

	たとえば、テキストエディタのような文字を入力するオブジェクトを使っている
	場合は、「Edit」というクラスを使ったオブジェクトがあるはずですし、ボタンが
	あれば「Button」があるはずです。
	これらの中から、送信したいオブジェクトの名前を選び指定します。
	たとえば、

		aplobj "EDIT"

	では、「Edit」のオブジェクトを送信先に選びます。
	しかし、「Edit」のオブジェクトが複数ある場合も中にはあります。
	そのような時は、

		aplobj "EDIT",3

	のようにIDをつけて何番目の「Edit」オブジェクトかを指定しなければ
	なりません。このIDは、「aplkey3.as」で表示される番号と同じものです。

	送信先を選んだ後は、それをアクティブにしなければなりません。
	多くのアプリケーションは(特にメニューを選ぶ時などは)、ウインドゥを
	アクティブにしなければキー入力を受け付けません。
	そこで、aplact命令を実行します。これは、aplsel命令やaplobj命令で選んだ
	送信先オブジェクトをアクティブにする命令です。

	これで準備は完了です。後は、実際にキーボードが押されるかわりに
	HSPから送り出すキーのメッセージを送信するだけです。
	キー入力の送信は、aplkey命令およびaplstr命令で行ないます。
	aplkey命令は、ボタンを指定して、１回押されたという情報を送ります。
	aplstr命令は、文字列を指定して、その内容をすべてキー情報として送信します。
	この２つの命令は、それぞれ異なる方式で送信を行なうため、アプリケーション
	によっては、aplkey命令に反応しないもの、aplstr命令に反応しないものも
	ある可能性がありますので注意してください。
	aplstr命令は、一度にたくさんのキー入力を送信することが可能ですが、
	[ALT]キーによるメニューの選択や、[CTRL]キーなどを使うことができません。
	aplkey命令は、[ALT]や[CTRL]などのキー情報を送ることができますが、
	送信できる文字は基本キーのみにか限られます。用途に応じて使い分けるように
	してください。また、aplkey命令の動作をより細かくしたaplkeyd命令および、
	aplkeyu命令も用意されています。

	aplstr命令は主に、入力ボックスに文字列を送るのに使用できます。
	たとえば、

		aplsel "ＨＳＰスクリプトエディタ"
		aplobj "EDIT"
		aplact
		wait 10
		aplstr "TEST KEYBOARD DATA..."
		wait 10

	のように使用すると、スクリプトエディタのエディタ部分に指定した文字列が
	入力されます。
	aplstr命令、aplkey命令の後には、wait命令かawait命令を入れるのを忘れないで
	ください。キー送信は、Windowsのキューに蓄積されるだけなので、実際に押した
	ことになるのは、waitが入ってからになります。

	aplkey命令の使い方は、たとえば、

		aplsel "ＨＳＰスクリプトエディタ"
		aplobj "EDIT"
		aplact
		wait 10
		aplkey 'F',4
		wait 10
		aplkey 'O'
		wait 10

	のように使用します。
	「aplkey 'F',4」は、[ALT]を押しながら「F」のキーを押した情報を送信
	します。2番目のパラメータが特殊キーの指定になっています。
	1ならば、シフトキー、2ならばCTRLキー、4ならばALTキーが同時に押されている
	ことになります。省略か0の時は、特殊キーは押されていないことになります。
	[ALT]+[F]キーにより、メニューのファイル(F)を選ぶことになります。
	次に「aplkey 'O'」で「O」のキーを押したことになり「ファイルを開く(O)」
	を選択します。

	このようにアプリケーション上でキーが押されるのと、まったく同じことを
	HSPのスクリプト上で指定していくことで、自動処理が可能になります。
	自動処理は、最初の設定は大変ですが何度も同じことを行なうような場合には、
	とても便利なこともあります。

	最後に、キー送信はHSP上のオブジェクトに直接行なうことも可能です。
	HSPのウインドゥからオブジエクトを選択してもいいですが、もっと簡単に
	行なうことができます。

		objsel 0
		aplfocus
		aplstr "TEST KEYBOARD DATA..."
		wait 10

	上の例では、objsel命令によって選ばれたID0のオブジェクトに対して、
	aplstr命令で文字列をキーボードから入力されたように送信されます。
	これは、objprm命令でも近いことができますが、カーソルの操作や、文字の追加
	など、アイデア次第で面白いことができるかもしれません。

	アプリケーションキャプチャーで最も苦労する点は、目的のウインドゥと
	オブジェクトを見つけ出すことです。これは、他のソフト開発者が作成した
	オブジェクトを推測しながら見つけなければならないので、構成が複雑な
	場合はとても見つけにくいと思います。
	「aplkey3.as」を使って、ウインドゥとオブジェクトの一覧を探すことが
	できますが、オブジェクトはソフトによっては階層構造になっていることも
	あります。特に最近のC++で作られたものや、MDIによるウインドゥが多数出て
	いるソフトなどは、オブジェクトの下にまた複数のオブジェクトが従属している
	ことも珍しくありません。このような場合は、aplobj命令でオブジェクトを
	選択した後にまた、aplobj命令でその下層のオブジェクトを選択するように
	してください。「aplkey3.as」では、[MORE]ボタンを押すと、下のリストで
	選択したオブジェクトのさらに下層のオブジェクトが表示されるようになって
	います。

	・追加情報(2000/11/5)

		Windows2000において、aplstr命令で全角文字を送信した場合に
		文字化けを起こす不具合が確認されています。
		これは一部のアプリケーションで起こる問題で現在調査中です。


-------------------------------------------------------------------------------
                                                HSP users manual / end of file 
-------------------------------------------------------------------------------
